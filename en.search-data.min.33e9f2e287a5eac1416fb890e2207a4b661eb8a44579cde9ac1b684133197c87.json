[{"id":0,"href":"/kademlia-api/docs/usage/abstraction/","title":"Abstraction","section":"Docs","content":" Abstraction # In this section, we go through the abstraction layer and what needs to be implemented in order for this API to work.\nNode ID # You should make a decision about size of your node IDs. This API supports Integer, Long and BigInteger by default. How a node ID is chosen can completely be different per use case. For example, this article suggests why it\u0026rsquo;s a good idea to have the hash of your node\u0026rsquo;s public key as your Node ID.\nConnection Info # This is just a Serializable interface that determines how nodes can communicate with each other. For example, one implementation can be a simple ip and port of a TCP socket.\nNode # Each kademlia node only sees other nodes as combination of Node ID and Connection Info.\nRoutingTable # RoutingTable and its buckets are Serializable. So you will easily be able to write it to a file. When you are creating an instance of your node, you can pass a new routing table or use one from disk. At this stage, there is no helper class for writing routing table on disk.\nYou can get proper implementation of routing table based on the ID type of your nodes. Available ones are: BigIntegerRoutingTable, LongRoutingTable and IntegerRoutingTable.\nProtocol # Kademlia Message # These are objects that represent a message that should be sent and delivered to other nodes. The default package where messages exist is io.ep2p.kademlia.protocol.message. Each message has certain type of serializable data attached to it, and it includes repliers\u0026rsquo; Node and status of the replier (if it\u0026rsquo;s alive or not).\nEach message has a type as well, which helps you during the serialization/deserialization process to determine which object should be created from the message.\nType KademliaMessage Class Purpose EMPTY EmptyKademliaMessage Just proves another message was delivered/accepted PING PingKademliaMessage Ping data to be sent to other nodes PONG PongKademliaMessage Ping response FIND_NODE_REQ FindNodeRequestMessage Request to find nodes close to current node FIND_NODE_RES FindNodeResponseMessage Response to find node request SHUTDOWN ShutdownKademliaMessage To tell other nodes that current node is shutting down DHT_LOOKUP DHTLookupKademliaMessage Lookup for data in DHT DHT_LOOKUP_RESULT DHTLookupResultKademliaMessage Result of lookup in DHT DHT_STORE DHTStoreKademliaMessage Store data in DHT DHT_STORE_RESULT DHTStoreResultKademliaMessage Result of storing data in DHT Message Sender # This is the networking layer. Should be implemented to send message (KademliaMessage) from the caller kademlia-node to receiver node. Serialization, Validation, and request sending are the basic things that shall be done here. The output of the API call probably has a response which should still be converted to the proper KademliaMessage and returned to the caller.\nCustom Message handler # In case you want to extend the protocol or change behaviours, you should add new or extend messages, and write custom handlers. You can then register your message handler on your KademliaNodes using kademliaNode.registerMessageHandler(type, handler)\nKey Hash Generator # The purpose of KeyHashGenerator interface is to bound DHT key size to network GUID size.\nFor example: when node IDs are BigInteger but DHT keys are String, a KeyHashGenerator implementation is needed to return hash of the String key as BigInteger value.\nKademlia Repository # This is simply DHT repository where keys and values are stored.\n"},{"id":1,"href":"/kademlia-api/docs/usage/kademlia-usage/","title":"Kademlia Node Usage","section":"Docs","content":" Kademlia Node Usage # In this section, we see how to create your Kademlia Nodes. Make sure you have read abstraction layer first.\nIntroduction # This library has 2 Kademlia related interfaces.\nKademliaNodeAPI: Main implementation is KademliaNode class. It only handles bootstrapping the network and keeping it alive. KademliaDHTNodeAPI: Extends KademliaNodeAPI interface. Main implementation is KademliaDHTNode which decorates any KademliaNodeAPI. Therefore, to create KademliaDHTNode you first need an instance of KademliaNodeAPI (KademliaNode).\nIt\u0026rsquo;s not as complicated as it may sound. Read below.\nKademlia Node # For only network bootstrapping and continues routing-table updates you can consider using default KademliaNodeAPI (interface) implementation: KademliaNode (impelementation).\nimport io.ep2p.kademlia.node.KademliaNodeAPI; import io.ep2p.kademlia.node.KademliaNode; KademliaNodeAPI\u0026lt;ID, C\u0026gt; node = new KademliaNode\u0026lt;\u0026gt;(id, connectionionInfo, routingTable, messageSenderAPI, nodeSettings); You can start the node by calling start() method, or you can bootstrap it by calling bootstrap(bootstrapNode) method and pass Node\u0026lt;ID, C\u0026gt; of bootstrap node as the parameter.\nYou can stop the node by calling stop() method which should gracefully stop the node and its executor services, or you can stop it by calling stopNow() method which will immediately the running jobs.\nGenerics # Note that KademliaNode and all its subclasses are Generic.\nThe first generic type is for ID of the node, and you can choose between Integer, Long, BigInteger as these are the only ones supported and you should decide on which on to use based on your GUID space size. For example on Eleuth Node System Biginteger is being used since node IDs are SHA1 of a public keys. You can choose the appropriate RoutingTable implementation based on this key size. There is an implementation available for all of the three supported ID types.\nThe second generic type is type of your class that implements ConnectionInfo.\nDHT Kademlia Node # For Distributed Hash Table you should consider using DHTKademliaNodeAPI interface. The main implementation is DHTKademliaNode class.\nThis class decorates KademliaNodeAPI as explained earlier. So you can instantiate it in 2 ways.\nA. Using constructor:\nnew DHTKademliaNode\u0026lt;\u0026gt;(kademliaNodeAPI, keyHashGenerator, kademliaRepository); B. Using builder:\nnew DHTKademliaNodeBuilder\u0026lt;\u0026gt;(id, connectionInfo, routingTable, messageSenderAPI, keyHashGenerator, kademliaRepository).build(); Performance # The general performance of this library depends on how the abstraction is implemented. However, there were a couple of performance improvement techniques in mind.\nPushing/Pulling Values for store() call # By default, when store method is called on a DHTKademliaNode it will keep pushing the \u0026lt;K,V\u0026gt; to the closest node. This may be a fine approach when the value is not large.\nAlternatively, you can choose the pulling mechanism, which will push only the key to find the closest node, and then the closest node to store a key will pull the value from the requester node.\nDHTStoreServiceAPI is in charge of handing the store mechanism. In order to override the default behavior you\u0026rsquo;d need to change the factory (DHTStoreServiceFactory) of your DHTKademliaNode.\nThe code snippet below shows you how to do so:\n// Creating a factory to return PullingDHTStoreService instance DHTStoreServiceFactory\u0026lt;I, C, K, V\u0026gt; dhtStoreServiceFactory = new DHTStoreServiceFactory\u0026lt;I, C, K, V\u0026gt;() { @Override public PushingDHTStoreService\u0026lt;I, C, K, V\u0026gt; getDhtStoreService(DHTKademliaNodeAPI\u0026lt;I, C, K, V\u0026gt; kademliaNodeAPI) { // Example of ExecutorService to use: Executors.newFixedThreadPool((int) Math.ceil(kademliaNodeAPI.getNodeSettings().getDhtExecutorPoolSize()/2)) return new PullingDHTStoreService\u0026lt;\u0026gt;(kademliaNodeAPI, YOUR_DESIRED_EXECUTOR_SERVICE_HERE); } }; new DHTKademliaNodeBuilder\u0026lt;\u0026gt;(...) .setDhtStoreServiceFactory(dhtStoreServiceFactory) .build(); Settings # You can configure your node by passing an instance of NodeSettings to KademliaNode or it\u0026rsquo;s subclasses. By default, they use the configuration from NodeSettings.Default which has static fields. You can edit NodeSettings.Default if all the nodes that you want to have in a single application are having the same configuration.\nNode Settings explanation:\nName Info IDENTIFIER_SIZE GUID Space AKA Routing table buckets count BUCKET_SIZE Max size of each bucket in routing table FIND_NODE_SIZE Size of results list when finding close nodes MAXIMUM_LAST_SEEN_AGE_TO_CONSIDER_ALIVE Value in seconds. If a node is older than this age, we will ping it before sending messages PING_SCHEDULE_TIME_VALUE Value in PING_SCHEDULE_TIME_UNIT to send pings in scheduler PING_SCHEDULE_TIME_UNIT TimeUnit for ping scheduler DHT_EXECUTOR_POOL_SIZE Size of ExecutorService in DHT for default constructor ENABLED_FIRST_STORE_REQUEST_FORCE_PASS Enables force pass on first store loop. Has negative impact on performance but makes sure another node also tries to store. Useful in situations where a node doesn\u0026rsquo;t know much about other nodes in the network Republishing Keys # In DHT we often require to republish keys. For example in a scenario where a node is shutting down there should be a mechanism for the node to republish its keys (and values) to other nodes before shutting down. This way there won\u0026rsquo;t be much data loss. Another scenario is when a new node joins the network, and we (as an individual node) may want to pass the data that the new node should hold to them. Therefore, we should periodically republish our data so closer nodes hold it.\nThis kademlia-api does not implement key republishing since 4.0.0-RELEASE version. This mechanism can be very tricky and very depended on how each developer implements their KademliaRepository. For example, when a single key can hold large amount of data we\u0026rsquo;d probably want to find a closer node first and then pass the data to them in different chunks.\n"}]