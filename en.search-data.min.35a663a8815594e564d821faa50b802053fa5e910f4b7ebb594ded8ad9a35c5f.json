[{"id":0,"href":"/kademlia-api/docs/usage/abstraction/","title":"Abstraction","section":"Docs","content":" Abstraction # In this section, we go through the abstraction layer and what needs to be implemented in order for this API to work.\nNode ID # You should make a decision about size of your node IDs. This API supports Integer, Long and BigInteger by default. How a node ID is chosen can completely be different per use case. For example, this article suggests why it\u0026rsquo;s a good idea to have the hash of your node\u0026rsquo;s public key as your Node ID.\nConnection Info # This is just a Serializable interface that determines how nodes can communicate with each other. For example, one implementation can be a simple ip and port of a TCP socket.\nNode # Each kademlia node only sees other nodes as combination of Node ID and Connection Info.\nRoutingTable # RoutingTable and its buckets are Serializable. So you will easily be able to write it to a file. When you are creating an instance of your node, you can pass a new routing table or use one from disk. At this stage, there is no helper class for writing routing table on disk.\nYou can get proper implementation of routing table based on the ID type of your nodes. Available ones are: BigIntegerRoutingTable, LongRoutingTable and IntegerRoutingTable.\nProtocol # Kademlia Message # These are objects that represent a message that should be sent and delivered to other nodes. The default package where messages exist is io.ep2p.kademlia.protocol.message. Each message has certain type of serializable data attached to it, and it includes repliers\u0026rsquo; Node and status of the replier (if it\u0026rsquo;s alive or not).\nEach message has a type as well, which helps you during the serialization/deserialization process to determine which object should be created from the message.\nType KademliaMessage Class Purpose EMPTY EmptyKademliaMessage Just proves another message was delivered/accepted PING PingKademliaMessage Ping data to be sent to other nodes PONG PongKademliaMessage Ping response FIND_NODE_REQ FindNodeRequestMessage Request to find nodes close to current node FIND_NODE_RES FindNodeResponseMessage Response to find node request SHUTDOWN ShutdownKademliaMessage To tell other nodes that current node is shutting down DHT_LOOKUP DHTLookupKademliaMessage Lookup for data in DHT DHT_LOOKUP_RESULT DHTLookupResultKademliaMessage Result of lookup in DHT DHT_STORE DHTStoreKademliaMessage Store data in DHT DHT_STORE_RESULT DHTStoreResultKademliaMessage Result of storing data in DHT Message Sender # This is the networking layer. Should be implemented to send message (KademliaMessage) from the caller kademlia-node to receiver node. Serialization, Validation, and request sending are the basic things that shall be done here. The output of the API call probably has a response which should still be converted to the proper KademliaMessage and returned to the caller.\nCustom Message handler # In case you want to extend the protocol or change behaviours, you should add new or extend messages, and write custom handlers. You can then register your message handler on your KademliaNodes using kademliaNode.registerMessageHandler(type, handler)\nKey Hash Generator # The purpose of KeyHashGenerator interface is to bound DHT key size to network GUID size.\nFor example: when node IDs are BigInteger but DHT keys are String, a KeyHashGenerator implementation is needed to return hash of the String key as BigInteger value.\nKademlia Repository # This is simply DHT repository where keys and values are stored.\n"},{"id":1,"href":"/kademlia-api/docs/usage/kademlia-usage/","title":"Kademlia Node Usage","section":"Docs","content":" Kademlia Node Usage # In this section, we see how to create your Kademlia Nodes. Make sure you have read abstraction layer first.\nIntroduction # This library has 2 Kademlia related interfaces.\nKademliaNodeAPI: Main implementation is KademliaNode class. It only handles bootstrapping the network and keeping it alive. KademliaDHTNodeAPI: Extends KademliaNodeAPI interface. Main implementation is KademliaDHTNode which decorates any KademliaNodeAPI. Therefore, to create KademliaDHTNode you first need an instance of KademliaNodeAPI (KademliaNode).\nIt\u0026rsquo;s not as complicated as it may sound. Read below.\nKademlia Node # For only network bootstrapping and continues routing-table updates you can consider using default KademliaNodeAPI (interface) implementation: KademliaNode (impelementation).\nimport io.ep2p.kademlia.node.KademliaNodeAPI; import io.ep2p.kademlia.node.KademliaNode; KademliaNodeAPI\u0026lt;ID, C\u0026gt; node = new KademliaNode\u0026lt;\u0026gt;(id, connectionionInfo, routingTable, messageSenderAPI, nodeSettings); You can start the node by calling start() method, or you can bootstrap it by calling bootstrap(bootstrapNode) method and pass Node\u0026lt;ID, C\u0026gt; of bootstrap node as the parameter.\nYou can stop the node by calling stop() method which should gracefully stop the node and its executor services, or you can stop it by calling stopNow() method which will immediately the running jobs.\nGenerics # Note that KademliaNodeAPI and all its implementations are Generic (KademliaNodeAPI\u0026lt;ID, C\u0026gt;).\nThe first generic type is for ID of the node, and you can choose between Integer, Long, BigInteger, and you should decide on which on to use based on your GUID space size.\nFor example on the other software I am developing BigInteger is being used as ID since node IDs are SHA1 of a cryptographic public keys.\nYou can choose the appropriate RoutingTable implementation based on this key size. There is an implementation available for all of the three supported ID types.\nThe second generic type is type of your class that implements ConnectionInfo. You are not limited on how to implement this class. The purpose of this class is to give information to other nodes on how to connect to this/current node.\nFor example, this could simply be TCP (or UDP if you prefer) IP/PORT of a node. In our Kademlia Netty implementation we are using \u0026ldquo;host\u0026rdquo; and \u0026ldquo;port\u0026rdquo; for example.\nDHT Kademlia Node # By default, KademliaAPI class does not focus on [D]istributed [H]ash [T]able. In case you want to use DHT, you should consider using DHTKademliaNodeAPI interface. The main implementation is DHTKademliaNode class.\nThis class decorates KademliaNodeAPI as explained earlier. So you can instantiate it in 2 ways.\nA. Using constructor:\nnew DHTKademliaNode\u0026lt;\u0026gt;(kademliaNodeAPI, keyHashGenerator, kademliaRepository); B. Using builder:\nnew DHTKademliaNodeBuilder\u0026lt;\u0026gt;(id, connectionInfo, routingTable, messageSenderAPI, keyHashGenerator, kademliaRepository).build(); Performance # The general performance of this library depends on how the abstraction is implemented. However, there were a couple of performance improvement techniques in mind.\nPushing/Pulling Values for store() call # By default, when store method is called on a DHTKademliaNode it will keep pushing the \u0026lt;K,V\u0026gt; to the closest node. This may be a fine approach when the value is not large.\nAlternatively, you can choose the pulling mechanism, which will push only the key to find the closest node, and then the closest node to store a key will pull the value from the requester node.\nDHTStoreServiceAPI is in charge of handing the store mechanism. In order to override the default behavior you\u0026rsquo;d need to change the factory (DHTStoreServiceFactory) of your DHTKademliaNode.\nThe code snippet below shows you how to do so:\n// Creating a factory to return PullingDHTStoreService instance DHTStoreServiceFactory\u0026lt;I, C, K, V\u0026gt; dhtStoreServiceFactory = new DHTStoreServiceFactory\u0026lt;I, C, K, V\u0026gt;() { @Override public PushingDHTStoreService\u0026lt;I, C, K, V\u0026gt; getDhtStoreService(DHTKademliaNodeAPI\u0026lt;I, C, K, V\u0026gt; kademliaNodeAPI) { // Example of ExecutorService to use: Executors.newFixedThreadPool((int) Math.ceil(kademliaNodeAPI.getNodeSettings().getDhtExecutorPoolSize()/2)) return new PullingDHTStoreService\u0026lt;\u0026gt;(kademliaNodeAPI, YOUR_DESIRED_EXECUTOR_SERVICE_HERE); } }; new DHTKademliaNodeBuilder\u0026lt;\u0026gt;(...) .setDhtStoreServiceFactory(dhtStoreServiceFactory) .build(); Settings # You can configure your node by passing an instance of NodeSettings to KademliaNode or it\u0026rsquo;s subclasses. By default, they use the configuration from NodeSettings.Default which has static fields. You can edit NodeSettings.Default if all the nodes that you want to have in a single application are having the same configuration.\nNode Settings explanation:\nName Info IDENTIFIER_SIZE GUID Space AKA Routing table buckets count BUCKET_SIZE Max size of each bucket in routing table FIND_NODE_SIZE Size of results list when finding close nodes MAXIMUM_LAST_SEEN_AGE_TO_CONSIDER_ALIVE Value in seconds. If a node is older than this age, we will ping it before sending messages PING_SCHEDULE_TIME_VALUE Value in PING_SCHEDULE_TIME_UNIT to send pings in scheduler PING_SCHEDULE_TIME_UNIT TimeUnit for ping scheduler DHT_EXECUTOR_POOL_SIZE Size of ExecutorService in DHT for default constructor ENABLED_FIRST_STORE_REQUEST_FORCE_PASS Enables force pass on first store loop. Has negative impact on performance but makes sure another node also tries to store. Useful in situations where a node doesn\u0026rsquo;t know much about other nodes in the network Republishing Keys # In DHT we often require to republish keys. For example in a scenario where a node is shutting down there should be a mechanism for the node to republish its keys (and values) to other nodes before shutting down. This way there won\u0026rsquo;t be much data loss. Another scenario is when a new node joins the network, and we (as an individual node) may want to pass the data that the new node should hold to them. Therefore, we should periodically republish our data so closer nodes hold it.\nThis kademlia-api does not implement key republishing since 4.0.0-RELEASE version. This mechanism can be very tricky and very depended on how each developer implements their KademliaRepository. For example, when a single key can hold large amount of data we\u0026rsquo;d probably want to find a closer node first and then pass the data to them in different chunks.\n"},{"id":2,"href":"/kademlia-api/docs/usage/examples/","title":"Examples","section":"Docs","content":" Examples # Assume we have a network of guid size 4, meaning there can be maximum 2^4 (16) nodes available in the network.\nAs discussed in Kademlia Node Usage, in real world examples, your node ids are unique and are generated through an algorithm that can proof a node id uniqueness to other nodes. We don\u0026rsquo;t do that in this example, we just assume a node as some integer id.\nNode instantiation # To begin with, we have to set some settings on how we want our network to behave. These settings are mutual between all nodes in the network.\n// Determining Identifier Size to 4, meaning we can have 2^4 nodes in network NodeSettings.Default.IDENTIFIER_SIZE = 4; // Determining the size of each routing table bucket size (we are limited to fixed bucket sizes in this implementation of kademlia) NodeSettings.Default.BUCKET_SIZE = 16; // Determining how often we want to ping other nodes to assure they are alive // This helps to give certain nodes better chance to stay alive in our routing table // Setting the ping scheduler time to 5 seconds NodeSettings.Default.PING_SCHEDULE_TIME_VALUE = 5; NodeSettings.Default.PING_SCHEDULE_TIME_UNIT = TimeUnit.SECONDS; // Other node settings are explained in Kademlia Node Usage documentation We assume you have implemented the ConnectionInfo class as explained in Kademlia Node Usage documentation. For our example purpose, the implementation is called: EmptyConnectionInfo\nNext step is to create a routing table. Again, default implementations support Integer, Long and BigInteger, and the value is stored on memory and is lost over program restarts.\n// First we build a NodeSettings instance from the Default values we filled earlier NodeSettings nodeSettings = NodeSettings.Default.build(); // Since the routing table factory requires NodeSetting information we pass it to the factory RoutingTableFactory\u0026lt;Integer, EmptyConnectionInfo, Bucket\u0026lt;Integer, EmptyConnectionInfo\u0026gt;\u0026gt; routingTableFactory = new DefaultRoutingTableFactory\u0026lt;\u0026gt;(nodeSettings); // Our routing table factory is ready. We can get routing table instances from this factory further on. In this example we want to create a \u0026ldquo;DHT Kademlia Node\u0026rdquo;. The hash table is Key -\u0026gt; Value storage. A key can be in any type of course.\nNext things we have to determine are:\nWhat is the Java class type of our DHT keys and values How do we hash and boung a key into the size of our network (imagine a key hash/value is 100 while we are in network size of 4 (16 nodes), we need to determine which node would be known as closest node to this key) The KeyHashGenerator interface is supposed to take a key as input and return a value which is bounded to the size of the network.\n// Assuming our keys are Integer and the network node IDs is Integer too. We already implemented SampleKeyHashGenerator to cover some of these cases. KeyHashGenerator\u0026lt;Integer, Integer\u0026gt; keyHashGenerator = new SampleKeyHashGenerator(NodeSettings.Default.IDENTIFIER_SIZE); Since we are implementing DHT, we need a \u0026ldquo;Repository/Storage\u0026rdquo; to keep the data in. You should implement your own.\nKademliaRepository\u0026lt;Integer, String\u0026gt; repository = new SampleRepository\u0026lt;\u0026gt;(); Next step we need to implement communication protocol for nodes, AKA \u0026ldquo;Message Sender\u0026rdquo;. This was explained in the Abstraction section.\nMessageSender\u0026lt;Integer, EmptyConnectionInfo\u0026gt; messageSenderAPI = ...; // Your implementation. You are almost done, lets instantiate a KademliaDHTNode from everything we prepared so far:\n// This node can story Integer -\u0026gt; String maps in its storage, and the Node IDs are in Integer format. The ID of the node is 0. int nodeId = 0; DHTKademliaNodeAPI\u0026lt;Integer, EmptyConnectionInfo, Integer, String\u0026gt; node = new DHTKademliaNodeBuilder\u0026lt;\u0026gt;( nodeId, new EmptyConnectionInfo(), routingTableFactory.getRoutingTable(nodeId), messageSenderAPI, keyHashGenerator, repository ).build(); // Start the node node.start() API # If you already have nodes in the network you can bootstrap them using other nodes:\nNode\u0026lt;Integer, EmptyConnectionInfo\u0026gt; otherNode = ...; // presentation of another node in the system Future\u0026lt;Boolean\u0026gt; bootstrapped = myNode.start(otherNode); System.out.print(\u0026#34;Could I bootstrap? \u0026#34; + bootstrapped.get()) To store data into DHT:\nString data = \u0026#34;something\u0026#34;; Integer key = data.hashCode(); Future\u0026lt;StoreAnswer\u0026lt;Integer, EmptyConnectionInfo, Integer\u0026gt;\u0026gt; storeFuture = node.store(key, data); StoreAnswer\u0026lt;Integer, EmptyConnectionInfo, Integer\u0026gt; storeAnswer = storeFuture.get(); System.out.println(storeAnswer.getNode().getId() + \u0026#34; stored \u0026#34; + storeAnswer.getKey()); To look up for data in DHT:\nFuture\u0026lt;LookupAnswer\u0026lt;Integer, EmptyConnectionInfo, Integer, String\u0026gt;\u0026gt; lookupFuture = node.lookup(key); LookupAnswer\u0026lt;Integer, EmptyConnectionInfo, Integer, String\u0026gt; lookupAnswer = lookupFuture.get(); Assertions.assertEquals(LookupAnswer.Result.FOUND, lookupAnswer.getResult()); System.out.println(lookupAnswer.getNode().getId() + \u0026#34; returned the data\u0026#34;); An example of a bootstrapped network with 16 nodes is available in this test case inside this repository.\nFor Netty implementation, you can find something similar (2 nodes only) in this test case.\nMore real example # You can check Kademlia Netty Standalone Test repository which is a runnable project that helps you get a sense of all of this. It\u0026rsquo;s implemented using Spring Shell to let you interact with it.\n"}]